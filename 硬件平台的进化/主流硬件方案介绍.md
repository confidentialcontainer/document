## AMD SME SEV
### AMD EPYC(霄龙)处理器引入了两个硬件安全组件：
AES-128硬件加密引擎：嵌入在内存控制器内，用于对内存数据进行加解密。 AMD Secure Processor（AMD-SP）：负责安全密钥的生成和管理。 Secure Memory Encryption (SME)：AMD在DRAM的控制器中添加了加解密模块，用来控制内内存数据的加密和解密。

Secure Encrypted Virtualization (SEV) ：将主内存加密功能与现有的AMD-V虚拟化体系结构来支持加密的虚拟机。 加密虚拟机不仅可以让虚拟机免受物理威胁，还可以免受其他虚拟机甚至是hypervisor本身。 因此，SEV代表了一种新的虚拟化安全范例，特别适用于虚拟机不需要完全信任其主机的hypervisor和管理员的云计算系统。 与SME一样，不需要修改应用程序软件即可支持SEV。

linux-4.16，Libvirt-4.5，qemu-2.12已经合入对SEV的支持。

### SME介绍
每个内存控制器包含高性能的高Advanced Encryption Standard(AES)引擎，可在将数据写入DRAM时对其进行加密，并在读取时将其解密，如图1所示。数据加密使用了额外的基于物理地址的调整方式，以防止密文块移动攻击。

SME的AES引擎使用的加密密钥是在每次系统重置时随机生成的，并且对软件不可见。密钥由集成在AMD SOC上的微控制器AMD Secure Processor（AMD-SP）（32位ARM Cortex A5）进行管理。密钥是由板载的符合SP 800-90的硬件随机数生成器生成，并存储在专用的硬件寄存器中，永远不会暴露在SOC之外。与稍后描述的SEV模同，SME不需要软件参与密钥管理。

OS或者Hypervisor可以指定哪些页进行加密。启动内存加密后，物理地址的第47位（又名C-bit，C代表enCrypted）用于标记该页是否被加密，对加密页进行访问时，加密和解密将由AES引擎自动完成。

通过AES引擎对内存进行加密和解密确实会导致DRAM存储器访问的额外延迟。这种延迟对软件的影响主要取决于系统负载，但估计对系统性能的总体影响很小。如果仅对一部分内存进行加密，则对性能的影响将较小，因为通常未加密的访问不会产生额外的延迟。

SME使用场景 全部内存加密 部分内存加密：在云计算场景下，可以仅将虚拟机使用的内存进行加密。 Transparent SME SME需要OS或Hypervisor的支持。AMD提供了叫Transparent SME（TSME）的模式，该模式下，所有内存都被加密（不管C-bit位是否为1）。TSME可以通过BIOS进行设置，当TSME开启时，其余的内存加密特性（包括SEV）均不可用。

### SEV介绍（2016年）
SEV主要的思想是为虚拟机内存进行加密保护，而且不同虚拟机之间以及宿主机不能直接读取或者窃取到虚拟机内存数据。SEV提供的虚拟机内存数据的加密功能，可以保护虚拟机内存免受物理攻击，跨虚拟机和来自Hypervisor的攻击。SEV功能使能后，物理地址的43 bit至47 bit分别用来标志Address Space ID(ASID)和C-bit，在通过页表访问虚拟机内存时，虚拟机的物理地址会携带与虚拟机对应的ASID的Tag，用来判断是访问哪个虚拟机的数据，或者是操作哪个虚拟机的数据。虚拟机的ASID在页表遍历时使用，用来区分TLB。在缓存（Cache）中，C-bit和ASID用来区分Cache Line。内存控制器中ASID用来区分虚拟机加密密钥（VEK），由于物理地址中的ASID是由硬件自动添加，软件无法直接修改，因此，从内存中读取的数据由内存控制器使用与之对应的VEK进行加解密。SEV模型如下图所示：

开启SEV功能的同时，要求Host使能SME功能，且虚拟机的VMCB中开启NPT功能，这是为了保证Nest Paging的工作过程中C-bit的控制不被软件干扰。由于有两级页表，因此会存在两级页表中PTE的C-bit组合，决定如何对最终的虚拟机内存页如何进行加解密，过程如下图所示：

需要注意的是，SEV对hypervisor和Guest都有要求。Guest必须适配SEV硬件特性，需要对C-bit进行控制；不允许对加密内存进行DMA操作，因此DMA只能使用gue st共享内存。特别是，与SME一样，使用不同的C-bit访问页之前，必须将该页从高速缓存中flush到内存。另外，在更换硬件内存加密密钥之前，hypervisor必须执行完整的高速缓存flush动作。

### SEV-ES介绍（2017年）
SEV-ES：Secure Encrypted Virtualization - Encrypted State

Guest寄存器状态也由安全密钥加密保护 Guest需要显式与hypervisor共享寄存器状态（使用Guest-Hypervisor Communication Block(GHCB)） 参考： https://blog.csdn.net/bemind1/article/details/111932930

## Intel SGX
### 背景
为什么要Intel SGX？ Intel SGX的目标就是为了解决目前日益受关注的“远程计算的安全问题”。

以云环境为例子，云租户会将自己的产品部署在云平台中，但是云平台现在普遍认为是一个不可信的地方，因为可能会有云平台管理者、同一云主机其他租户的恶意攻击，也可能云平台本身存在漏洞，使得黑客轻易的攻击并拿到Ring0权限（就好比我租了房东的一间卧室，我害怕房东、其他租户、陌生人对我房间东张西望，甚至搞破坏。）。这种情况下，云租户就开始担心了。

与此同时，Intel SGX出现了，它对自己做了一个安全内存Enclave的概念，对安全内存实施权限控制、加密等安全措施，防止别人（Ring0级别的攻击者）非法对安全内存内的敏感数据代码进行机密性、完整性、真实性的破坏（Intel SGX对可用性并不保障），其中完整性主要通过可信建立Enclave保证，真实性通过由硬件背书的本地/远程认证来确保。就好比我租了房东卧室后，我对自己卧室的墙进行加固，并且对门加上自己的锁（内存访问控制），甚至让房间内的东西也进行上锁（内存加密），不让人家偷窥、搞破坏。

除了云环境，Intel SGX旨在防所有Ring0级别的攻击者（OS、VMM等），服务器中也可以对敏感部分就行加固。开发商下放版权也可以放到客户端的SGX保证版权保护。此外还有对区块链这种分布式客户端的形式就行客户端本地的SGX保护。

Intel SGX狭义上是指一组CPU指令，该组指令增强应用程序代码和数据的安全性，为它们提供更强的保护以防泄漏或修改。开发人员可将敏感信息放入Enclave中，Enclave是内存中具有更强安全保护性的执行区域。

Intel SGX广义上是指以SGX指令为基础所构建的包括Intel CPU等硬件、CPU提供的硬件指令、驱动、Platform Software（用于构建不可信运行时环境uRTS）、SDK（用于构建可信运行时环境tRTS）等在内的一种新的安全机制，既Intel SGX软硬件栈。

SGX平台需要Intel 6代及以上处理器，并且BIOS支持并开启了SGX选项。

### 常用名词
Intel SGX：Intel Software Guard Extensions的简称。

Enclave：下述条目针对Enclave不同的角度来表述，实际表述中不太加以区分，并且更侧重于指Enclave实例。

Enclave内存：Enclave是内存中具有更强安全保护性的执行区域。

Encalve环境：通过Enclave内存及硬件保护机制、可信运行时共同来保护敏感代码数据的环境，或者说安全世界。

Enclave代码：希望放在Enclave中执行的敏感代码数据。

Enclave文件：保存着Enclave代码数据的镜像文件。与实例的区别好比程序代码与进程的区别，一个静态，一个动态。

Enclave实例：指从Enclave文件具体执行起来的进程。

EPC：Enclave Page Cache。Enclave的物理内存是一种抽象的表示，Enclave物理内存会最终落实到一个个具体的物理页，这些页就是来自于EPC。也就是说EPC是一块加密的处于系统保留内存的物理内存区域，用来存放Enclave的页和SGX数据结构。

EP：Enclave Page。EPC中一个个具体的页。为了方便读者理解，也可称为EPC页

SGX世界观：SGX将软硬件资源等划分成安全世界和不安全世界

安全世界：包括可信运行时和用户的Enclave实例，安全世界中Enclave实例会利用可信运行时提供的API完成敏感功能等。而每个开发者进程都有自己的独立的Enclave环境，不同Enclave的安全世界相互隔离。

不安全世界：包括不可信运行时和用户的非敏感代码以及具有内核权限的驱动。

uRTS：Untrusted Runtime Service，不可信运行时环境，不安全世界、普通世界的一部分。

tRTS：Trusted Runtime Service，可信运行时环境，安全世界、Enclave环境的一部分。

AE：Architectural Enclave。由SGX平台提供完成特定功能的特殊的Enclave，包括：Launch Enclave，用于决定在当前SGX平台上运行哪些其他Enclave（主要指用户的Enclave实例）；Provisioning Enclave，提供长期平台证明密钥；Quoting Enclave，使用非对称平台证明密钥，用于为远程使用者签署本地证明报告；Platform Service Enclave，平台服务Enclave，用于提供如可信的时间等安全功能。

OCALL：从安全世界进入不安全世界所用到的桥函数。

ECALL：从不安全世界进入安全世界所用到的桥函数。

ISV：Individual Software Vendor个体软件厂商

SgxEdger8r：SGX Edge Routine，主要用于在编译过程中对.edl文件中的ecall和ocall重新封装编写，即将用户编写的e/ocall改写成实际执行的e/ocall

### 常用结构体
SECS：SGX Enclave Control Structure。每个Enclave实例都具有一个该结构体，用于保存关于该实例的信息，如Enclave的线性基址（对于整个程序而言）和大小。保存在EPC中该Enclave的内存空间，只能由CPU访问。

TCS：Thread Control Structure。每个Enclave实例可以拥有很多个具体执行Enclave函数的Worker Thread，每个线程都对应一个TCS，用于描述这个线程的信息，如线程执行flag、SSA的位置、当前使用的SSA（若干个SSA组成一个栈）。存储在EPC中，只能由处理器访问。

SIGSTRUCT：ENCLAVE SIGNATURE STRUCTURE。每个Enclave文件具有一个SIGSTRUCT来证明它是被某个SGX平台签署的。（见后续“EINIT指令过程”章节）

EINITTOKEN：EINIT TOKEN STRUCTURE。从Enclave文件创建Enclave实例时，需要向AE申请一个令牌，后续EINIT指令使用EINITTOKEN结构来检查是否允许执行Enclave。（见后续“EINIT指令过程”章节）

EPCM：ENCLAVE PAGE CACHE MAP。被硬件用来跟踪EPC内容，每一个Entry对应一个EP。软件不可访问。每个Entry会说明EPC页的线性地址等。

SGX的可信保障及优点 Enclave这块特殊内存采用加密技术，保障内存代码、数据的机密性和完整性。 任何对Enclave进行的访问都需要经过严格地访问控制。 可信计算基础（TCB）缩小到CPU的SGX Enclave这一硬件保障设施，而不再要求操作系统和特权程序是可信的。 支持虚拟化技术和容器技术。 SGX的不足 Enclave处于用户态，如果Enclave中的代码数据依赖于Enclave外部数据，则存在安全隐患，需要Enclave代码对传入的外部数据检查。 SGX 本身无法抵御侧信道攻击，因为不是为侧信道防御而设计的，但是可以在程序开发过程中进行设计防御。 Enclave 需要对原程序进行改造，通过特殊的.edl文件声明将敏感代码放入Enclave中执行，将不敏感代码放在普通内存中执行。 Enclave所支持的特殊加密内存的大小很小，因此开发者应该只将至关重要的敏感的代码数据放入其中。 SGX会产生一定程度的系统开销。 SGX与TrustZone区别 TrustZone将系统划分为安全世界和普通世界，实现了执行环境以及存储、网络和屏幕等设备的安全隔离，敏感代码放入安全世界执行。TrustZone里面程序是直面硬件资源的，并且TrustZone内部的多个程序间并没有安全隔离，直到有相关工作在TrustZone里面安置了一个安全内核，如T6安全微内核（上海瓶钵主导的工作，在Trustzone里实现了安全操作系统的功能，实现了敏感应用之间的隔离，还可以让开发者更好地使用物理硬件，安全微内核只有六千行代码，非常轻量级，同时经过安全审计）。【SecTEE】等工作也试图在TrustZone内部提供Enclave的概念（包括了SGX所提供的可信度量、加密、访问控制、密封、本地认证、远程认证中的部分功能），之前也听到有相关工作在ARM芯片的普通世界构建Enclave，而不是在TrustZone内部，似乎硬件实现机制有一些区别，忘记了。

SGX中，对于每一个进程，可以创建多个类似于“安全世界”的Enclave，并且不同进程之间的Enclave是互相硬件隔离的——通过MEE使用独立的密钥加密Enclave内存进行保障。

参考：https://blog.csdn.net/clh14281055/article/details/109091363

## ARM TrustZone
ARM TrustZone是ARM公司推出的SoC及CPU系统范围的安全解决方案，目前已在一些采用ARM指令集的应用处理器上广泛使用。本篇文章旨在对ARM TrustZone技术的体系架构、面临的安全隐患和应用进行简单的概述。

### TrustZone体系架构
ARM TrustZone是基于硬件的安全功能，它通过对原有硬件架构进行修改，在处理器层次引入了两个不同权限的保护域——安全世界和普通世界，任何时刻处理器仅在其中的一个环境内运行。同时这两个世界完全是硬件隔离的，并具有不同的权限，正常世界中运行的应用程序或操作系统访问安全世界的资源受到严格的限制，反过来安全世界中运行的程序可以正常访问正常世界中的资源。这种两个世界之间的硬件隔离和不同权限等属性为保护应用程序的代码和数据提供了有效的机制：通常正常世界用于运行商品操作系统（例如Android、iOS等），该操作系统提供了正常执行环境（Rich Execution Environment，REE）；安全世界则始终使用安全的小内核（TEE-kernel）提供可信执行环境（Trusted Execution Environment，TEE），机密数据可以在TEE中被存储和访问。这样一来即使正常世界中的操作系统被破坏或入侵（例如iOS已被越狱或Android已被ROOT），黑客依旧无法获取存储在TEE中的机密数据。

除了Cortex-A微架构外，ARM发布的新一代Cortex-M微架构同样为TrustZone提供了硬件支持。与Cortex-A相同的是，Cortex-M依旧将处理器运行状态划分为安全世界和正常世界，并阻止运行于正常世界的软件直接访问安全资源。不同的是，Cortex-M已针对更快的上下文切换和低功耗应用进行了优化。具体来说，Cortex-M中世界之间的划分是基于内存映射的，并且转换是在异常处理代码中自动发生的（如图1（b）所示）。这意味着，当从安全内存运行代码时，处理器状态为安全，而当从非安全内存运行代码时，处理器状态为非安全。Cortex-M中的TrustZone技术排除了监视模式，也不需要任何安全的监视软件，这大大减少了世界切换延迟，使得世界之间的转换为更高效。为了在两个世界之间架起桥梁，Cortex-M引入了三个新指令：secure gateway（SG），branch with exchange to non-secure state（BXNS）和branch with link and exchange to non-secure state（BLXNS）。 SG指令用于在安全入口点的第一条指令中从非安全状态切换到安全状态。安全软件使用BXNS指令来返回到非安全程序；最后，安全软件使用BLXNS指令来调用非安全功能。此外，Cortex-M中的状态转换也可以由异常和中断触发。

### 基于TrustZone的TEE系统
TrustZone通过硬件隔离出的安全世界提供了TEE，根据在安全世界中运行的可信程序的不同，又可以将其提供的TEE划分为两类：TEE内核与TEE服务。

在TEE内核中，可信程序实现一套基本的OS功能，以管理多个TEE实例，每个实例托管一个特定的应用程序。TEE内核实现的功能有：管理安全世界的内存、对每个TEE实施内存保护、处理TEE与OS之间的通信以及为TEE应用程序提供API 。为了解决正常世界中的操作系统和TEE内核的协同工作问题，业界提出了一系列有关TEE内核的标准。在2009年，Open Mobile Terminal Platform (OMTP)便提出了一个TEE标准，该标准定义了TEE应该支持的一系列安全功能。随后，GlobalPlatform组织以此为基础定义了可信应用程序可以依赖的内部API，以及正常世界的OS软件与TEE中的应用程序进行交互的通信接口。许多常见的TEE产品方案都遵守GlobalPlatform标准，例如SierraTEE、T6 、OP-TEE、Open-TEE和Samsung KNOX。

与TEE内核不同，TEE服务只实现某种特定功能，它们不需要任何低级OS逻辑来管理它们自己的内存和跨世界的通信。为了避免相互干扰，设备上只能部署一种TEE服务。与TEE内核相比，这是一个缺点，后者允许多个应用程序在独立的TEE实例中运行。但是，TEE内核的缺点是，与部署单个TEE服务的系统相比，它们通常依赖于较大的TCB，这意味着相比于TEE服务，TEE内核可能存在着更多的漏洞。常见的TEE服务包括：可信存储、安全的身份验证和加密、Rich OS验证和监控、可信I/O等。

### TrustZone安全隐患
当前已发现的TrustZone漏洞主要可以归纳为两类：一类是缺乏鲁棒的TEE实现，导致无法为应用程序提供安全的运行容器；另一类是实现TrustZone的硬件存在缺陷，攻击者可以针对硬件漏洞发起攻击，进而获取存储的机密数据。

根据国家漏洞数据库（National Vulnerability Database，NVD）和一些公司（例如，高通，华为和三星）发布的安全公告，已发现的有关TrustZone和基于TrustZone的TEE的漏洞已达到了130多个。这些漏洞中的大多数都与TEE内核以及TEE驱动程序有关，例如缺乏输入验证、缓冲区溢出、过度读取、未初始化变量以及竞争条件等。出现这种情况的原因在于，尽管在设计TEE时能够保证其具有安全的体系结构以及能够提供完善而鲁棒的隔离，但是TEE内部运行的代码可能包含一些漏洞，攻击者可以利用这些漏洞破坏TEE并进而损害整个系统的信任状态。针对TEE中运行的代码存在的漏洞，业界尚缺乏用于验证和分析代码安全性的框架，同时TEE中也缺乏适当防御机制。

除了与TEE中运行的代码有关的漏洞外，在过去的几年中，研究者还发现了许多与实现TrustZone的硬件相关的漏洞，这些漏洞涉及构成平台信任根的组件、缓存、电源管理机制和FPGA等。

### TrustZone的应用
#### 用于提高物联网设备的安全
随着“万物互联”概念的到来，物联网设备被大量的部署，而这一新的互联网浪潮能否成功在很大程度上取决于数十亿种不同连接设备的安全性。最近的一些针对物联网设备的攻击表明，设计不佳的连接设备被黑客入侵后会造成巨大的损失。因此，保护物联网设备的安全是实现“万物互联”必须攻克的一个难题。

为了解决这个问题，ARM将TrustZone扩展到新一代微控制器。借助内置于物联网设备上的TrustZone，物联网设备制造商或软件开发者可以以较低的代价建立起可靠的安全防御体系。如今，ARM正在大力投资于物联网和嵌入式设备的规范与标准化，并且发布了平台安全体系结构（Platform Security Architecture，PSA）规范以及随附的名为Trusted Firmware-M的开源软件项目。 PSA主要是为保护低开销的IoT设备而设计的，可以在基于Cortex-M、Cortex-R和基于Cortex-A的设备上实现。不同的物联网设备制造商或开发者可以根据PSA，提供适合于自己设备的实现。

#### 用于移动端环境与云计算环境的隐私保护
现有的基于TrustZone开发的应用主要用于提高移动平台上数据和应用程序的安全性，通过将用户的机密数据保存在基于TrustZone构建的TEE中，即使黑客完全控制了REE中的OS，也无法获取这些机密数据。早在iPhone 5s中，Apple便已利用TrustZone保护其Touch ID，这可确保即使iOS受到完全破坏，用户的指纹数据仍然无法被窃取。 2017年，谷歌也强制性要求所有配备指纹扫描仪的Android设备都需具有TEE。 如今，几乎所有的手机和平板电脑都部署了TEE。

随着ARM处理器在移动设备市场中的普及，一些云计算厂商也推出了基于ARM架构的产品，在云端使用ARM架构已是大势所趋。目前已有一些研究迈出了在云上使用TrustZone的第一步，例如在Zookeeper 中便使用TrustZone构建了受TEE保护的隐私代理，用于保护Zookeeper中存储的所有数据的安全。
